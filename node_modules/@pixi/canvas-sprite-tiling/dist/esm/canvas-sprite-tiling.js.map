{"version":3,"file":"canvas-sprite-tiling.js","sources":["../../src/TilingSprite.ts"],"sourcesContent":["import { TilingSprite } from '@pixi/sprite-tiling';\nimport { canvasUtils } from '@pixi/canvas-renderer';\nimport { CanvasRenderTarget } from '@pixi/utils';\nimport { Matrix, Point } from '@pixi/math';\n\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\n\nconst worldMatrix = new Matrix();\nconst patternMatrix = new Matrix();\nconst patternRect = [new Point(), new Point(), new Point(), new Point()];\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @protected\n * @function _renderCanvas\n * @memberof PIXI.TilingSprite#\n * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer\n */\nTilingSprite.prototype._renderCanvas = function _renderCanvas(renderer: CanvasRenderer): void\n{\n    const texture = this._texture;\n\n    if (!texture.baseTexture.valid)\n    {\n        return;\n    }\n\n    const context = renderer.context;\n    const transform = this.worldTransform;\n    const baseTexture = texture.baseTexture;\n    const source = baseTexture.getDrawableSource();\n    const baseTextureResolution = baseTexture.resolution;\n\n    // create a nice shiny pattern!\n    if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tint)\n    {\n        this._textureID = this._texture._updateID;\n        // cut an object from a spritesheet..\n        const tempCanvas = new CanvasRenderTarget(texture._frame.width,\n            texture._frame.height,\n            baseTextureResolution);\n\n        // Tint the tiling sprite\n        if (this.tint !== 0xFFFFFF)\n        {\n            this._tintedCanvas = canvasUtils.getTintedCanvas(this, this.tint) as HTMLCanvasElement;\n            tempCanvas.context.drawImage(this._tintedCanvas, 0, 0);\n        }\n        else\n        {\n            tempCanvas.context.drawImage(source,\n                -texture._frame.x * baseTextureResolution, -texture._frame.y * baseTextureResolution);\n        }\n        this._cachedTint = this.tint;\n        this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');\n    }\n\n    // set context state..\n    context.globalAlpha = this.worldAlpha;\n    renderer.setBlendMode(this.blendMode);\n\n    this.tileTransform.updateLocalTransform();\n    const lt = this.tileTransform.localTransform;\n    const W = this._width;\n    const H = this._height;\n\n    /*\n     * # Implementation Notes\n     *\n     * The tiling transform is not simply a transform on the tiling sprite's local space. If that\n     * were, the bounds of the tiling sprite would change. Rather the tile transform is a transform\n     * on the \"pattern\" coordinates each vertex is assigned.\n     *\n     * To implement the `tileTransform`, we issue drawing commands in the pattern's own space, which\n     * is defined as:\n     *\n     * Pattern_Space = Local_Space x inverse(tileTransform)\n     *\n     * In other words,\n     * Local_Space = Pattern_Space x tileTransform\n     *\n     * We draw the pattern in pattern space, because the space we draw in defines the pattern's coordinates.\n     * In other words, the pattern will always \"originate\" from (0, 0) in the space we draw in.\n     *\n     * This technique is equivalent to drawing a pattern texture, and then finding a quadrilateral that becomes\n     * the tiling sprite's local bounds under the tileTransform and mapping that onto the screen.\n     *\n     * ## uvRespectAnchor\n     *\n     * The preceding paragraph discusses the case without considering `uvRespectAnchor`. The `uvRespectAnchor` flags\n     * where the origin of the pattern space is. Assuming the tileTransform includes no translation, without\n     * loss of generality: If uvRespectAnchor = true, then\n     *\n     * Local Space (0, 0) <--> Pattern Space (0, 0) (where <--> means \"maps to\")\n     *\n     * Here the mapping is provided by trivially by the tileTransform (note tileTransform includes no translation. That\n     * means the invariant under all other transforms are the origins)\n     *\n     * Otherwise,\n     *\n     * Local Space (-localBounds.x, -localBounds.y) <--> Pattern Space (0, 0)\n     *\n     * Here the mapping is provided by the tileTransfrom PLUS some \"shift\". This shift is done POST-tileTransform. The shift\n     * is equal to the position of the top-left corner of the tiling sprite in its local space.\n     *\n     * Hence,\n     *\n     * Local_Space = Pattern_Space x tileTransform x shiftTransform\n     */\n\n    // worldMatrix is used to convert from pattern space to world space.\n    //\n    // worldMatrix = tileTransform x shiftTransform x worldTransfrom\n    //             = patternMatrix x worldTransform\n    worldMatrix.identity();\n\n    // patternMatrix is used to convert from pattern space to local space. The drawing commands are issued in pattern space\n    // and this matrix is used to inverse-map the local space vertices into it.\n    //\n    // patternMatrix = tileTransfrom x shiftTransform\n    patternMatrix.copyFrom(lt);\n\n    // Apply shiftTransform into patternMatrix. See $1.1\n    if (!this.uvRespectAnchor)\n    {\n        patternMatrix.translate(-this.anchor.x * W, -this.anchor.y * H);\n    }\n\n    patternMatrix.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);\n    worldMatrix.prepend(patternMatrix);\n    worldMatrix.prepend(transform);\n\n    renderer.setContextTransform(worldMatrix);\n\n    // Fill the pattern!\n    context.fillStyle = this._canvasPattern;\n\n    // The position in local space we are drawing the rectangle: (lx, ly, lx + W, ly + H)\n    const lx = this.anchor.x * -W;\n    const ly = this.anchor.y * -H;\n\n    // Set pattern rect in local space first.\n    patternRect[0].set(lx, ly);\n    patternRect[1].set(lx + W, ly);\n    patternRect[2].set(lx + W, ly + H);\n    patternRect[3].set(lx, ly + H);\n\n    // Map patternRect into pattern space.\n    for (let i = 0; i < 4; i++)\n    {\n        patternMatrix.applyInverse(patternRect[i], patternRect[i]);\n    }\n\n    /*\n     * # Note about verification of theory\n     *\n     * As discussed in the implementation notes, you can verify that `patternRect[0]` will always be (0, 0) in case of\n     * `uvRespectAnchor` false and tileTransform having no translation. Indeed, because the pattern origin should map\n     * to the top-left corner of the tiling sprite in its local space.\n     */\n\n    context.beginPath();\n    context.moveTo(patternRect[0].x, patternRect[0].y);\n\n    for (let i = 1; i < 4; i++)\n    {\n        context.lineTo(patternRect[i].x, patternRect[i].y);\n    }\n\n    context.closePath();\n    context.fill();\n};\n"],"names":[],"mappings":"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"}