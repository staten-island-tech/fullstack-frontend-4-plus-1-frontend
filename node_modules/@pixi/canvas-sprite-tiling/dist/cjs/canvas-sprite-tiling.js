/*!
 * @pixi/canvas-sprite-tiling - v6.3.2
 * Compiled Wed, 04 May 2022 17:49:13 UTC
 *
 * @pixi/canvas-sprite-tiling is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
'use strict';

var spriteTiling = require('@pixi/sprite-tiling');
var canvasRenderer = require('@pixi/canvas-renderer');
var utils = require('@pixi/utils');
var math = require('@pixi/math');

var worldMatrix = new math.Matrix();
var patternMatrix = new math.Matrix();
var patternRect = [new math.Point(), new math.Point(), new math.Point(), new math.Point()];
/**
 * Renders the object using the Canvas renderer
 *
 * @protected
 * @function _renderCanvas
 * @memberof PIXI.TilingSprite#
 * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer
 */
spriteTiling.TilingSprite.prototype._renderCanvas = function _renderCanvas(renderer) {
    var texture = this._texture;
    if (!texture.baseTexture.valid) {
        return;
    }
    var context = renderer.context;
    var transform = this.worldTransform;
    var baseTexture = texture.baseTexture;
    var source = baseTexture.getDrawableSource();
    var baseTextureResolution = baseTexture.resolution;
    // create a nice shiny pattern!
    if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tint) {
        this._textureID = this._texture._updateID;
        // cut an object from a spritesheet..
        var tempCanvas = new utils.CanvasRenderTarget(texture._frame.width, texture._frame.height, baseTextureResolution);
        // Tint the tiling sprite
        if (this.tint !== 0xFFFFFF) {
            this._tintedCanvas = canvasRenderer.canvasUtils.getTintedCanvas(this, this.tint);
            tempCanvas.context.drawImage(this._tintedCanvas, 0, 0);
        }
        else {
            tempCanvas.context.drawImage(source, -texture._frame.x * baseTextureResolution, -texture._frame.y * baseTextureResolution);
        }
        this._cachedTint = this.tint;
        this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');
    }
    // set context state..
    context.globalAlpha = this.worldAlpha;
    renderer.setBlendMode(this.blendMode);
    this.tileTransform.updateLocalTransform();
    var lt = this.tileTransform.localTransform;
    var W = this._width;
    var H = this._height;
    /*
     * # Implementation Notes
     *
     * The tiling transform is not simply a transform on the tiling sprite's local space. If that
     * were, the bounds of the tiling sprite would change. Rather the tile transform is a transform
     * on the "pattern" coordinates each vertex is assigned.
     *
     * To implement the `tileTransform`, we issue drawing commands in the pattern's own space, which
     * is defined as:
     *
     * Pattern_Space = Local_Space x inverse(tileTransform)
     *
     * In other words,
     * Local_Space = Pattern_Space x tileTransform
     *
     * We draw the pattern in pattern space, because the space we draw in defines the pattern's coordinates.
     * In other words, the pattern will always "originate" from (0, 0) in the space we draw in.
     *
     * This technique is equivalent to drawing a pattern texture, and then finding a quadrilateral that becomes
     * the tiling sprite's local bounds under the tileTransform and mapping that onto the screen.
     *
     * ## uvRespectAnchor
     *
     * The preceding paragraph discusses the case without considering `uvRespectAnchor`. The `uvRespectAnchor` flags
     * where the origin of the pattern space is. Assuming the tileTransform includes no translation, without
     * loss of generality: If uvRespectAnchor = true, then
     *
     * Local Space (0, 0) <--> Pattern Space (0, 0) (where <--> means "maps to")
     *
     * Here the mapping is provided by trivially by the tileTransform (note tileTransform includes no translation. That
     * means the invariant under all other transforms are the origins)
     *
     * Otherwise,
     *
     * Local Space (-localBounds.x, -localBounds.y) <--> Pattern Space (0, 0)
     *
     * Here the mapping is provided by the tileTransfrom PLUS some "shift". This shift is done POST-tileTransform. The shift
     * is equal to the position of the top-left corner of the tiling sprite in its local space.
     *
     * Hence,
     *
     * Local_Space = Pattern_Space x tileTransform x shiftTransform
     */
    // worldMatrix is used to convert from pattern space to world space.
    //
    // worldMatrix = tileTransform x shiftTransform x worldTransfrom
    //             = patternMatrix x worldTransform
    worldMatrix.identity();
    // patternMatrix is used to convert from pattern space to local space. The drawing commands are issued in pattern space
    // and this matrix is used to inverse-map the local space vertices into it.
    //
    // patternMatrix = tileTransfrom x shiftTransform
    patternMatrix.copyFrom(lt);
    // Apply shiftTransform into patternMatrix. See $1.1
    if (!this.uvRespectAnchor) {
        patternMatrix.translate(-this.anchor.x * W, -this.anchor.y * H);
    }
    patternMatrix.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);
    worldMatrix.prepend(patternMatrix);
    worldMatrix.prepend(transform);
    renderer.setContextTransform(worldMatrix);
    // Fill the pattern!
    context.fillStyle = this._canvasPattern;
    // The position in local space we are drawing the rectangle: (lx, ly, lx + W, ly + H)
    var lx = this.anchor.x * -W;
    var ly = this.anchor.y * -H;
    // Set pattern rect in local space first.
    patternRect[0].set(lx, ly);
    patternRect[1].set(lx + W, ly);
    patternRect[2].set(lx + W, ly + H);
    patternRect[3].set(lx, ly + H);
    // Map patternRect into pattern space.
    for (var i = 0; i < 4; i++) {
        patternMatrix.applyInverse(patternRect[i], patternRect[i]);
    }
    /*
     * # Note about verification of theory
     *
     * As discussed in the implementation notes, you can verify that `patternRect[0]` will always be (0, 0) in case of
     * `uvRespectAnchor` false and tileTransform having no translation. Indeed, because the pattern origin should map
     * to the top-left corner of the tiling sprite in its local space.
     */
    context.beginPath();
    context.moveTo(patternRect[0].x, patternRect[0].y);
    for (var i = 1; i < 4; i++) {
        context.lineTo(patternRect[i].x, patternRect[i].y);
    }
    context.closePath();
    context.fill();
};
//# sourceMappingURL=canvas-sprite-tiling.js.map
