/*!
 * @pixi/canvas-graphics - v6.3.2
 * Compiled Wed, 04 May 2022 17:49:13 UTC
 *
 * @pixi/canvas-graphics is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
this.PIXI = this.PIXI || {};
var _pixi_canvas_graphics = (function (exports, core, math, canvasRenderer$1, graphics) {
    'use strict';

    /**
     * Utilities for polygon
     * @class
     * @private
     */
    var PolygonUtils = /** @class */ (function () {
        function PolygonUtils() {
        }
        /**
        * Calculate points of an offset polygon
        * @see {@link http://csharphelper.com/blog/2016/01/enlarge-a-polygon-in-c/}
        *
        * @private
        * @param {number[]} points - polygon coordinates
        * @param {number} offset
        * @return {number[]} - offset points
        */
        PolygonUtils.offsetPolygon = function (points, offset) {
            var offsetPoints = [];
            var length = points.length;
            offset = PolygonUtils.isPolygonClockwise(points) ? offset : -1 * offset;
            for (var j = 0; j < length; j += 2) {
                // Find location for the points before and after j
                var i = (j - 2);
                if (i < 0) {
                    i += length;
                }
                var k = (j + 2) % length;
                // Move the points by the offset
                var v1x = points[j] - points[i];
                var v1y = points[j + 1] - points[i + 1];
                var len = Math.sqrt((v1x * v1x) + (v1y * v1y));
                v1x /= len;
                v1y /= len;
                v1x *= offset;
                v1y *= offset;
                var norm1x = -v1y;
                var norm1y = v1x;
                var pij1 = [points[i] + norm1x, points[i + 1] + norm1y];
                var pij2 = [points[j] + norm1x, points[j + 1] + norm1y];
                var v2x = points[k] - points[j];
                var v2y = points[k + 1] - points[j + 1];
                len = Math.sqrt((v2x * v2x) + (v2y * v2y));
                v2x /= len;
                v2y /= len;
                v2x *= offset;
                v2y *= offset;
                var norm2x = -v2y;
                var norm2y = v2x;
                var pjk1 = [points[j] + norm2x, points[j + 1] + norm2y];
                var pjk2 = [points[k] + norm2x, points[k + 1] + norm2y];
                // Find where the shifted lines ij and jk intersect.
                var intersectPoint = PolygonUtils
                    .findIntersection(pij1[0], pij1[1], pij2[0], pij2[1], pjk1[0], pjk1[1], pjk2[0], pjk2[1]);
                if (intersectPoint) {
                    offsetPoints.push.apply(offsetPoints, intersectPoint);
                }
            }
            return offsetPoints;
        };
        /**
        * Determine the intersection point of two line segments
        * @see {@link here http://paulbourke.net/geometry/pointlineplane/}
        *
        * @private
        * @param {number} x1 - x-coordinate of start point at first line
        * @param {number} y1 - y-coordinate of start point at first line
        * @param {number} x2 - x-coordinate of end point at first line
        * @param {number} y2 - y-coordinate of end point at first line
        * @param {number} x3 - x-coordinate of start point at second line
        * @param {number} y3 - y-coordinate of start point at second line
        * @param {number} x4 - x-coordinate of end point at second line
        * @param {number} y4 - y-coordinate of end point at second line
        * @returns {[number, number] | null} - [x, y] coordinates of intersection
        */
        PolygonUtils.findIntersection = function (x1, y1, x2, y2, x3, y3, x4, y4) {
            var denominator = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));
            var numeratorA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));
            var numeratorB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));
            // lines are parallel
            if (denominator === 0) {
                // lines are coincident
                if (numeratorA === 0 && numeratorB === 0) {
                    return [(x1 + x2) / 2, (y1 + y2) / 2];
                }
                return null;
            }
            var uA = numeratorA / denominator;
            return [x1 + (uA * (x2 - x1)), y1 + (uA * (y2 - y1))];
        };
        /**
         * Determine polygon are clockwise or counterclockwise
         * @see {@link https://stackoverflow.com/questions/1165647}
         *
         * @private
         * @param {number[]} polygon - polygon coordinates
         * @return {boolean}
         */
        PolygonUtils.isPolygonClockwise = function (polygon) {
            var sum = 0;
            for (var i = 0, j = polygon.length - 2; i < polygon.length; j = i, i += 2) {
                sum += (polygon[i] - polygon[j]) * (polygon[i + 1] + polygon[j + 1]);
            }
            return sum > 0;
        };
        return PolygonUtils;
    }());

    /*
     * @author Mat Groves
     *
     * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
     * for creating the original PixiJS version!
     * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they
     * now share 4 bytes on the vertex buffer
     *
     * Heavily inspired by LibGDX's CanvasGraphicsRenderer:
     * https://github.com/libgdx/libgdx/blob/1.0.0/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java
     */
    /**
     * Renderer dedicated to drawing and batching graphics objects.
     *
     * @class
     * @protected
     * @memberof PIXI
     */
    var CanvasGraphicsRenderer = /** @class */ (function () {
        /**
         * @param renderer - A reference to the current renderer.
         */
        function CanvasGraphicsRenderer(renderer) {
            this._svgMatrix = null;
            this._tempMatrix = new math.Matrix();
            this.renderer = renderer;
        }
        /**
         * calculates fill/stroke style for canvas
         *
         * @private
         * @param style - A graphics {@link PIXI.FILL_STYLE} where if `texture` is specified then a tinted CanvasPattern
         * will be used for the fill.stroke
         * @param tint - color to set the fill/stroke too.
         */
        CanvasGraphicsRenderer.prototype._calcCanvasStyle = function (style, tint) {
            var res;
            if (style.texture && style.texture.baseTexture !== core.Texture.WHITE.baseTexture) {
                if (style.texture.valid) {
                    res = canvasRenderer$1.canvasUtils.getTintedPattern(style.texture, tint);
                    this.setPatternTransform(res, style.matrix || math.Matrix.IDENTITY);
                }
                else {
                    res = '#808080';
                }
            }
            else {
                res = "#" + ("00000" + (tint | 0).toString(16)).slice(-6);
            }
            return res;
        };
        /**
         * Renders a Graphics object to a canvas.
         *
         * @param graphics - the actual graphics object to render
         */
        CanvasGraphicsRenderer.prototype.render = function (graphics) {
            var renderer = this.renderer;
            var context = renderer.context;
            var worldAlpha = graphics.worldAlpha;
            var transform = graphics.transform.worldTransform;
            renderer.setContextTransform(transform);
            renderer.setBlendMode(graphics.blendMode);
            var graphicsData = graphics.geometry.graphicsData;
            var contextFillStyle;
            var contextStrokeStyle;
            var tintR = ((graphics.tint >> 16) & 0xFF) / 255;
            var tintG = ((graphics.tint >> 8) & 0xFF) / 255;
            var tintB = (graphics.tint & 0xFF) / 255;
            for (var i = 0; i < graphicsData.length; i++) {
                var data = graphicsData[i];
                var shape = data.shape;
                var fillStyle = data.fillStyle;
                var lineStyle = data.lineStyle;
                var fillColor = data.fillStyle.color | 0;
                var lineColor = data.lineStyle.color | 0;
                if (data.matrix) {
                    renderer.setContextTransform(transform.copyTo(this._tempMatrix).append(data.matrix));
                }
                if (fillStyle.visible) {
                    var fillTint = ((((fillColor >> 16) & 0xFF) / 255 * tintR * 255 << 16)
                        + (((fillColor >> 8) & 0xFF) / 255 * tintG * 255 << 8)
                        + (((fillColor & 0xFF) / 255) * tintB * 255));
                    contextFillStyle = this._calcCanvasStyle(fillStyle, fillTint);
                }
                if (lineStyle.visible) {
                    var lineTint = ((((lineColor >> 16) & 0xFF) / 255 * tintR * 255 << 16)
                        + (((lineColor >> 8) & 0xFF) / 255 * tintG * 255 << 8)
                        + (((lineColor & 0xFF) / 255) * tintB * 255));
                    contextStrokeStyle = this._calcCanvasStyle(lineStyle, lineTint);
                }
                context.lineWidth = lineStyle.width;
                context.lineCap = lineStyle.cap;
                context.lineJoin = lineStyle.join;
                context.miterLimit = lineStyle.miterLimit;
                if (data.type === math.SHAPES.POLY) {
                    context.beginPath();
                    var tempShape = shape;
                    var points = tempShape.points;
                    var holes = data.holes;
                    var outerArea = void 0;
                    var innerArea = void 0;
                    var px = void 0;
                    var py = void 0;
                    var holesDirection = void 0;
                    context.moveTo(points[0], points[1]);
                    for (var j = 2; j < points.length; j += 2) {
                        context.lineTo(points[j], points[j + 1]);
                    }
                    if (tempShape.closeStroke) {
                        context.closePath();
                    }
                    if (holes.length > 0) {
                        holesDirection = [];
                        outerArea = 0;
                        px = points[0];
                        py = points[1];
                        for (var j = 2; j + 2 < points.length; j += 2) {
                            outerArea += ((points[j] - px) * (points[j + 3] - py))
                                - ((points[j + 2] - px) * (points[j + 1] - py));
                        }
                        for (var k = 0; k < holes.length; k++) {
                            points = holes[k].shape.points;
                            if (!points) {
                                continue;
                            }
                            innerArea = 0;
                            px = points[0];
                            py = points[1];
                            for (var j = 2; j + 2 < points.length; j += 2) {
                                innerArea += ((points[j] - px) * (points[j + 3] - py))
                                    - ((points[j + 2] - px) * (points[j + 1] - py));
                            }
                            if (innerArea * outerArea < 0) {
                                context.moveTo(points[0], points[1]);
                                for (var j = 2; j < points.length; j += 2) {
                                    context.lineTo(points[j], points[j + 1]);
                                }
                            }
                            else {
                                context.moveTo(points[points.length - 2], points[points.length - 1]);
                                for (var j = points.length - 4; j >= 0; j -= 2) {
                                    context.lineTo(points[j], points[j + 1]);
                                }
                            }
                            if (holes[k].shape.closeStroke) {
                                context.closePath();
                            }
                            holesDirection[k] = innerArea * outerArea < 0;
                        }
                    }
                    if (fillStyle.visible) {
                        context.globalAlpha = fillStyle.alpha * worldAlpha;
                        context.fillStyle = contextFillStyle;
                        context.fill();
                    }
                    if (lineStyle.visible) {
                        this.paintPolygonStroke(tempShape, lineStyle, contextStrokeStyle, holes, holesDirection, worldAlpha, context);
                    }
                }
                else if (data.type === math.SHAPES.RECT) {
                    var tempShape = shape;
                    if (fillStyle.visible) {
                        context.globalAlpha = fillStyle.alpha * worldAlpha;
                        context.fillStyle = contextFillStyle;
                        context.fillRect(tempShape.x, tempShape.y, tempShape.width, tempShape.height);
                    }
                    if (lineStyle.visible) {
                        var alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));
                        var width = tempShape.width + (2 * alignmentOffset);
                        var height = tempShape.height + (2 * alignmentOffset);
                        context.globalAlpha = lineStyle.alpha * worldAlpha;
                        context.strokeStyle = contextStrokeStyle;
                        context.strokeRect(tempShape.x - alignmentOffset, tempShape.y - alignmentOffset, width, height);
                    }
                }
                else if (data.type === math.SHAPES.CIRC) {
                    var tempShape = shape;
                    // TODO - need to be Undefined!
                    context.beginPath();
                    context.arc(tempShape.x, tempShape.y, tempShape.radius, 0, 2 * Math.PI);
                    context.closePath();
                    if (fillStyle.visible) {
                        context.globalAlpha = fillStyle.alpha * worldAlpha;
                        context.fillStyle = contextFillStyle;
                        context.fill();
                    }
                    if (lineStyle.visible) {
                        if (lineStyle.alignment !== 0.5) {
                            var alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));
                            context.beginPath();
                            context.arc(tempShape.x, tempShape.y, tempShape.radius + alignmentOffset, 0, 2 * Math.PI);
                            context.closePath();
                        }
                        context.globalAlpha = lineStyle.alpha * worldAlpha;
                        context.strokeStyle = contextStrokeStyle;
                        context.stroke();
                    }
                }
                else if (data.type === math.SHAPES.ELIP) {
                    var tempShape = shape;
                    var drawShapeOverStroke = lineStyle.alignment === 1;
                    if (!drawShapeOverStroke) {
                        this.paintEllipse(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);
                    }
                    if (lineStyle.visible) {
                        if (lineStyle.alignment !== 0.5) {
                            var kappa = 0.5522848;
                            var alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));
                            var sW = (tempShape.width + alignmentOffset) * 2;
                            var sH = (tempShape.height + alignmentOffset) * 2;
                            var sX = tempShape.x - (sW / 2);
                            var sY = tempShape.y - (sH / 2);
                            var sOx = (sW / 2) * kappa;
                            var sOy = (sH / 2) * kappa;
                            var sXe = sX + sW;
                            var sYe = sY + sH;
                            var sXm = sX + (sW / 2);
                            var sYm = sY + (sH / 2);
                            context.beginPath();
                            context.moveTo(sX, sYm);
                            context.bezierCurveTo(sX, sYm - sOy, sXm - sOx, sY, sXm, sY);
                            context.bezierCurveTo(sXm + sOx, sY, sXe, sYm - sOy, sXe, sYm);
                            context.bezierCurveTo(sXe, sYm + sOy, sXm + sOx, sYe, sXm, sYe);
                            context.bezierCurveTo(sXm - sOx, sYe, sX, sYm + sOy, sX, sYm);
                            context.closePath();
                        }
                        context.globalAlpha = lineStyle.alpha * worldAlpha;
                        context.strokeStyle = contextStrokeStyle;
                        context.stroke();
                    }
                    if (drawShapeOverStroke) {
                        this.paintEllipse(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);
                    }
                }
                else if (data.type === math.SHAPES.RREC) {
                    var tempShape = shape;
                    var drawShapeOverStroke = lineStyle.alignment === 1;
                    if (!drawShapeOverStroke) {
                        this.paintRoundedRectangle(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);
                    }
                    if (lineStyle.visible) {
                        if (lineStyle.alignment !== 0.5) {
                            var width = tempShape.width;
                            var height = tempShape.height;
                            var alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));
                            var sRx = tempShape.x - alignmentOffset;
                            var sRy = tempShape.y - alignmentOffset;
                            var sWidth = tempShape.width + (2 * alignmentOffset);
                            var sHeight = tempShape.height + (2 * alignmentOffset);
                            var radiusOffset = alignmentOffset * (lineStyle.alignment >= 1
                                ? Math.min(sWidth / width, sHeight / height) : Math.min(width / sWidth, height / sHeight));
                            var sRadius = tempShape.radius + radiusOffset;
                            var sMaxRadius = Math.min(sWidth, sHeight) / 2;
                            sRadius = sRadius > sMaxRadius ? sMaxRadius : sRadius;
                            context.beginPath();
                            context.moveTo(sRx, sRy + sRadius);
                            context.lineTo(sRx, sRy + sHeight - sRadius);
                            context.quadraticCurveTo(sRx, sRy + sHeight, sRx + sRadius, sRy + sHeight);
                            context.lineTo(sRx + sWidth - sRadius, sRy + sHeight);
                            context.quadraticCurveTo(sRx + sWidth, sRy + sHeight, sRx + sWidth, sRy + sHeight - sRadius);
                            context.lineTo(sRx + sWidth, sRy + sRadius);
                            context.quadraticCurveTo(sRx + sWidth, sRy, sRx + sWidth - sRadius, sRy);
                            context.lineTo(sRx + sRadius, sRy);
                            context.quadraticCurveTo(sRx, sRy, sRx, sRy + sRadius);
                            context.closePath();
                        }
                        context.globalAlpha = lineStyle.alpha * worldAlpha;
                        context.strokeStyle = contextStrokeStyle;
                        context.stroke();
                    }
                    if (drawShapeOverStroke) {
                        this.paintRoundedRectangle(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);
                    }
                }
            }
        };
        /**
         * Paint stroke for polygon and holes
         *
         * @private
         * @param shape - Shape to be drawn
         * @param lineStyle - Line style for the shape
         * @param contextStrokeStyle - The strokeStyle for the canvas context
         * @param holes - Holes to be added to the shape
         * @param holesDirection -
         * @param worldAlpha - The multiplied alpha of the displayObject
         * @param context - The canvas context
         */
        CanvasGraphicsRenderer.prototype.paintPolygonStroke = function (shape, lineStyle, contextStrokeStyle, holes, holesDirection, worldAlpha, context) {
            if (lineStyle.alignment !== 0.5) {
                var alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));
                var offsetPoints = PolygonUtils.offsetPolygon(shape.points, alignmentOffset);
                var points = void 0;
                context.beginPath();
                context.moveTo(offsetPoints[0], offsetPoints[1]);
                for (var j = 2; j < offsetPoints.length; j += 2) {
                    context.lineTo(offsetPoints[j], offsetPoints[j + 1]);
                }
                if (shape.closeStroke) {
                    context.closePath();
                }
                for (var k = 0; k < holes.length; k++) {
                    points = holes[k].shape.points;
                    offsetPoints = PolygonUtils.offsetPolygon(points, alignmentOffset);
                    if (holesDirection[k]) {
                        context.moveTo(offsetPoints[0], offsetPoints[1]);
                        for (var j = 2; j < offsetPoints.length; j += 2) {
                            context.lineTo(offsetPoints[j], offsetPoints[j + 1]);
                        }
                    }
                    else {
                        context.moveTo(offsetPoints[offsetPoints.length - 2], offsetPoints[offsetPoints.length - 1]);
                        for (var j = offsetPoints.length - 4; j >= 0; j -= 2) {
                            context.lineTo(offsetPoints[j], offsetPoints[j + 1]);
                        }
                    }
                    if (holes[k].shape.closeStroke) {
                        context.closePath();
                    }
                }
            }
            context.globalAlpha = lineStyle.alpha * worldAlpha;
            context.strokeStyle = contextStrokeStyle;
            context.stroke();
        };
        /**
         * Paint Ellipse
         *
         * @private
         * @param shape - Shape to be drawn
         * @param fillStyle - Fill for the shape
         * @param lineStyle - Line style for the shape
         * @param contextFillStyle - The canvas context fill style
         * @param worldAlpha - The multiplied alpha of the displayObject
         * @param context - The canvas context
         */
        CanvasGraphicsRenderer.prototype.paintEllipse = function (shape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context) {
            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
            var w = shape.width * 2;
            var h = shape.height * 2;
            var x = shape.x - (w / 2);
            var y = shape.y - (h / 2);
            var kappa = 0.5522848;
            var ox = (w / 2) * kappa; // control point offset horizontal
            var oy = (h / 2) * kappa; // control point offset vertical
            var xe = x + w; // x-end
            var ye = y + h; // y-end
            var xm = x + (w / 2); // x-middle
            var ym = y + (h / 2); // y-middle
            if (lineStyle.alignment === 0) {
                context.save();
            }
            context.beginPath();
            context.moveTo(x, ym);
            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
            context.closePath();
            if (lineStyle.alignment === 0) {
                context.clip();
            }
            if (fillStyle.visible) {
                context.globalAlpha = fillStyle.alpha * worldAlpha;
                context.fillStyle = contextFillStyle;
                context.fill();
            }
            if (lineStyle.alignment === 0) {
                context.restore();
            }
        };
        /**
         * Paint Rounded Rectangle
         *
         * @private
         * @param shape - Shape to be drawn
         * @param fillStyle - Fill for the shape
         * @param lineStyle - Line style for the shape
         * @param contextFillStyle - The canvas context fill style
         * @param worldAlpha - The multiplied alpha of the displayObject
         * @param context - The canvas context
         */
        CanvasGraphicsRenderer.prototype.paintRoundedRectangle = function (shape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context) {
            var rx = shape.x;
            var ry = shape.y;
            var width = shape.width;
            var height = shape.height;
            var radius = shape.radius;
            var maxRadius = Math.min(width, height) / 2;
            radius = radius > maxRadius ? maxRadius : radius;
            if (lineStyle.alignment === 0) {
                context.save();
            }
            context.beginPath();
            context.moveTo(rx, ry + radius);
            context.lineTo(rx, ry + height - radius);
            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
            context.lineTo(rx + width - radius, ry + height);
            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
            context.lineTo(rx + width, ry + radius);
            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
            context.lineTo(rx + radius, ry);
            context.quadraticCurveTo(rx, ry, rx, ry + radius);
            context.closePath();
            if (lineStyle.alignment === 0) {
                context.clip();
            }
            if (fillStyle.visible) {
                context.globalAlpha = fillStyle.alpha * worldAlpha;
                context.fillStyle = contextFillStyle;
                context.fill();
            }
            if (lineStyle.alignment === 0) {
                context.restore();
            }
        };
        CanvasGraphicsRenderer.prototype.setPatternTransform = function (pattern, matrix) {
            if (this._svgMatrix === false) {
                return;
            }
            if (!this._svgMatrix) {
                var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                if (svg && svg.createSVGMatrix) {
                    this._svgMatrix = svg.createSVGMatrix();
                }
                if (!this._svgMatrix || !pattern.setTransform) {
                    this._svgMatrix = false;
                    return;
                }
            }
            this._svgMatrix.a = matrix.a;
            this._svgMatrix.b = matrix.b;
            this._svgMatrix.c = matrix.c;
            this._svgMatrix.d = matrix.d;
            this._svgMatrix.e = matrix.tx;
            this._svgMatrix.f = matrix.ty;
            pattern.setTransform(this._svgMatrix.inverse());
        };
        /** destroy graphics object */
        CanvasGraphicsRenderer.prototype.destroy = function () {
            this.renderer = null;
            this._svgMatrix = null;
            this._tempMatrix = null;
        };
        return CanvasGraphicsRenderer;
    }());

    var canvasRenderer;
    var tempMatrix = new math.Matrix();
    /**
     * Generates a canvas texture. Only available with **pixi.js-legacy** bundle
     * or the **@pixi/canvas-graphics** package.
     * @method generateCanvasTexture
     * @memberof PIXI.Graphics#
     * @param {PIXI.SCALE_MODES} scaleMode - The scale mode of the texture.
     * @param {number} resolution - The resolution of the texture.
     * @return {PIXI.Texture} The new texture.
     */
    graphics.Graphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode, resolution) {
        if (resolution === void 0) { resolution = 1; }
        var bounds = this.getLocalBounds();
        var canvasBuffer = core.RenderTexture.create({
            width: bounds.width,
            height: bounds.height,
            scaleMode: scaleMode,
            resolution: resolution,
        });
        if (!canvasRenderer) {
            canvasRenderer = new canvasRenderer$1.CanvasRenderer();
        }
        this.transform.updateLocalTransform();
        this.transform.localTransform.copyTo(tempMatrix);
        tempMatrix.invert();
        tempMatrix.tx -= bounds.x;
        tempMatrix.ty -= bounds.y;
        canvasRenderer.render(this, { renderTexture: canvasBuffer, clear: true, transform: tempMatrix });
        var texture = core.Texture.from(canvasBuffer.baseTexture._canvasRenderTarget.canvas, {
            scaleMode: scaleMode,
        });
        texture.baseTexture.setResolution(resolution);
        return texture;
    };
    graphics.Graphics.prototype.cachedGraphicsData = [];
    /**
     * Renders the object using the Canvas renderer
     *
     * @method _renderCanvas
     * @memberof PIXI.Graphics#
     * @private
     * @param {PIXI.CanvasRenderer} renderer - The renderer
     */
    graphics.Graphics.prototype._renderCanvas = function _renderCanvas(renderer) {
        if (this.isMask === true) {
            return;
        }
        this.finishPoly();
        renderer.plugins.graphics.render(this);
    };

    exports.CanvasGraphicsRenderer = CanvasGraphicsRenderer;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

})({}, PIXI, PIXI, PIXI, PIXI);
Object.assign(this.PIXI, _pixi_canvas_graphics);
//# sourceMappingURL=canvas-graphics.js.map
